# [ 제네릭이 필요한 이유 ]
- 먼저 숫자를 보관하고 꺼낼 수 있는 IntegerBox를 만들어 보자
```java
public class IntegerBox {

    private Integer value;

    public void set(Integer value) {
        this.value = value;
    }

    public Integer get() {
        return value;
    }
}
```
- 아래 코드와 같이 IntegerBox를 사용할 수 있다.
```java
    public static void main(String[] args) {
        IntegerBox integerBox = new IntegerBox();
        integerBox.set(10); //오토 박싱
        Integer integer = integerBox.get();
        System.out.println("integer = " + integer);
    }
```

- 이번엔 문자열을 저장하고 꺼낼 수 있는 StringBox를 만들어 보자
```java
public class StringBox {

    private String value;

    public void set(String object) {
        this.value = object;
    }

    public String get() {
        return value;
    }
}
```
- 아래와 같이 StringBox도 사용할 수 있다.
```java
    public static void main(String[] args) {
        IntegerBox integerBox = new IntegerBox();
        integerBox.set(10); //오토 박싱
        Integer integer = integerBox.get();
        System.out.println("integer = " + integer);

        StringBox stringBox = new StringBox();
        stringBox.set("hello");
        String str = stringBox.get();
        System.out.println("str = " + str);
    }
```
- 여기까지 코드를 살펴 보면 IntegerBox와 StringBox는 타입만
다를 뿐 전부 같은 코드인데 클래스를 새로 만들어야 하기 때문에 굉장히 
비효율적이다 라는 생각이 들 것이다.
- 모든 타입을 전부 클래스로 만들어야 한다면 굉장히 번거롭다.
- 이 문제를 제네릭을 적용하면 해결 할 수 있다.
- 이에 앞서 먼저 다형성을 통해 문제를 해결 해 보자.


# [ 다형성을 통한 중복 해결 시도 ]
- 위에서 타입이 다른것이 문제 였는데 Object를 사용하면 문제를 해결 할 수 있다.
- Object는 모든 타입의 부모 타입이기 때문이다.
```java
public class ObjectBox {

    private Object value;

    public void set(Object object) {
        this.value = object;
    }

    public Object get() {
        return value;
    }
}
```
- 위 클래스는 아래와 같이 사용할 수 있다.
```java
    public static void main(String[] args) {
        ObjectBox integerBox = new ObjectBox();
        integerBox.set(10);
        Integer integer = (Integer) integerBox.get(); //Object -> Integer 캐스팅
        System.out.println("integer = " + integer);

        ObjectBox stringBox = new ObjectBox();
        stringBox.set("hello");
        String str = (String) stringBox.get(); //Object -> Integer 캐스팅
        System.out.println("str = " + str);

        //잘못된 타입의 인수 전달시
        integerBox.set("100");
        Integer result = (Integer) integerBox.get(); // String -> Integer 캐스팅 예외
        System.out.println("result = " + result);
    }
```

- 중복은 해결이 되었지만 반환 타입이 맞지 않는 문제와 잘못된 인수를 전달 할 수 있는 문제가 있다.

###  반환 타입이 맞지 않는 문제 
- 예를들어 아래의 integerBox의 반환 타입은 Object이다.
- 따라서 Integer로 반환 받길 원한다면 캐스팅을 해줘야 한다.
```java
ObjectBox integerBox = new ObjectBox();
integerBox.set(10);
// 캐스팅 해줘야 함
Integer integer = (Integer) integerBox.get();
```

### 잘못된 타입의 인수 전달 문제
- 개발자는 이름을 integerBox로 만들어 integer 타입이 파라미터로
전달 되기를 기대했다.
- 하지만 어떠한 제한도 두지 않았기 때문에 다른 타입이 얼마든지 들어갈 수 있다.

```java
ObjectBox integerBox = new ObjectBox();
//잘못된 타입의 인수 전달시
integerBox.set("100");
Integer result = (Integer) integerBox.get(); // String -> Integer 캐스팅 예외
System.out.println("result = " + result);
```
### 정리
- Object 타입을 통해 다형성의 개념을 활용해서 코드의 중복을 제거하고
기존 코드를 재사용할 수 있게 되었다.
- 하지만 항상 다운 캐스팅을 해줘야 하며 원하지 않은 타입의 값이 들어올 수 있는
문제가 있다.
- 즉, 이 방식은 타입 안정성 ( 잘못된 타입의 데이터가 사용될 경우 프로그램이 실행되기 전 컴파일 단계에서 에러를 발생 시키는 것이 타입 안정성이 높은 것 ) 이 떨어진다.

# [ 제네릭 적용 ]
- 제네릭을 사용하면 앞선 문제 모두를 해결 하여 코드 재사용과 타입 안정성이라는
두마리 토끼를 모두 잡을 수 있다.
- `<>`를 사용한 클래스를 제네릭 클래스라고 한다.
- 해당 기호를 다이아몬드라 부르고 내부에 `T`와 같은 타입 매개변수를
적어두면 된다.
- 이렇게 하면 해당 클래스의 인스턴스를 생성하는 시점에 원하는 타입을 전달하여
타입 매개변수 자리에 전달한 타입을 지정할 수 있다.
```java
public class GenericBox<T> {

    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```
- 제네릭 클래스 사용
```java
public static void main(String[] args) {
    GenericBox<Integer> integerBox = new GenericBox<Integer>(); //생성 시점에 T의 타입 결정
    integerBox.set(10);
    //integerBox.set("문자100"); // Integer 타입만 허용, 컴파일 오류
    Integer integer = integerBox.get(); // Integer 타입 반환 (캐스팅 X)
    System.out.println("integer = " + integer);

    GenericBox<String> stringBox = new GenericBox<String>();
    stringBox.set("hello"); // String 타입만 허용
    String str = stringBox.get(); // String 타입만 반환
    System.out.println("str = " + str);

    //원하는 모든 타입 사용 가능
    GenericBox<Double> doubleBox = new GenericBox<Double>();
    doubleBox.set(10.5);
    Double doubleValue = doubleBox.get();
    System.out.println("doubleValue = " + doubleValue);

    //타입 추론: 생성하는 제네릭 타입 생략 가능
    GenericBox<Integer> integerBox2 = new GenericBox<>(); // 타입 추론:     
}
```

### 타입 추론
- 이전 코드를 보면 변수를 선언할 때와 객체를 생성할 때 <Integer> 가 두번 나온다.
- 자바는 타입 추론 기능을 제공하기 때문에 변수를 선언할 때만 타입을 적어주면
알아서 타입을 추론하기 때문제 new 키워드 다음에는 타입을 지정하지 않아도 된다.
```java
GenericBox<Integer> integerBox = new GenericBox<Integer>() // 타입 직접 입력
GenericBox<Integer> integerBox2 = new GenericBox<>() // 타입 추론
```


# [ 제네릭 용어의 관례 ]
- 제네릭의 핵심은 사용할 타입을 미리 결정하지 않는 다는 점이다.
- 클래스 내부에서 사용할 타입을 클래스 정의 시점이 아니라 생성 시점에서 결정 하는 것.


### 제네릭 ? 
- 제네릭이라는 단어는 일반적인, 범용적인이라는 뜻의 영어 단어다.
- 풀어서 해석해 보면 특정 타입에 속한 것이 아니라, 범용적으로 사용할 수 있다는 뜻

### 제네릭 타입
- 일반적으로 반환 타입과 같은 용어를 사용하는데 이때 클래스도 하나의 타입이 될 수 있다.
- 여기서 제네릭 타입이란 타입 매개변수를 사용하는 클래스나 인터페이스를 의미한다.

### 타입 매개변수
- 제네릭 타입이나 메서드에서 사용되는 변수로, 추후 실제 타입으로 대체 된다.
- GenericBox<T> 에서 T를 타입 매개변수라고 한다.

### 타입 인자
- 제네릭 타입을 사용할 때 실제 전달되는 타입을 의미한다.
- GenericBox<Integer> 라면 Integer가 타입 인자가 된다. 

### 제네릭 명명 관례
- 타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다.
  하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.
- 주로 사용하는 키워드는 다음과 같다.
  - E - Element
  - K - Key
  - N - Number
  - T - Type
  - V - Value
  - S,U,V etc. - 2nd, 3rd, 4th types

### 제네릭 기타
- 아래와 같이 한번에 여러 타입 매개변수를 선언할 수도 있다.
```java
class Data<K,V> {}
```
- 제네릭의 타입 인자로 기본형 ( int, double )은 사용할 수 없다. 래퍼 클래스 (Integer, Double)을 사용해야 한다.
그 이유는 자바에서 제네릭의 경우 데이터를 Object로 바꾸어 관리하는데 기본 타입은 객체가 아니라서 
Object를 상속 받지 않기에 타입 인자로 사용할 수 없는 것.

### Raw 타입
- 제네릭 타입을 사용할 때는 항상 `<>` 를 사용해서 사용시점에 원하는 타입을 지정해야 한다.
  그런데 아래와 같이 `<>` 을 지정하지 않을 수 있는데, 이런 것을 로 타입(raw type), 또는 원시 타입이라한다.
- 이 경우 타입 매개 변수가 Object가 된다고 이해하면 된다.
- 제네릭이 자바가 처음 등장할 때 부터 있었던 것이 아니라 자바가 오랜기간 사용된 이후에 등장했기 때문에 제네
  릭이 없던 시절의 과거 코드와의 하위 호환이 필요했다. 그래서 어쩔 수 없이 이런 로 타입을 지원한다.
- 정리하면 로 타입을 사용하지 않아야 한다.
  만약에 `Object` 타입을 사용해야 한다면 다음과 같이 타입 인자로 `Object` 를 지정해서 사용하면 된다.
```java
public static void main(String[] args) {
    GenericBox integerBox = new GenericBox();
    //GenericBox<Object> integerBox = new GenericBox<>(); // 권장
    integerBox.set(10);
    Integer result = (Integer) integerBox.get();
    System.out.println("result = " + result);
}
```