# [ 제네릭이 필요한 이유 ]
- 먼저 숫자를 보관하고 꺼낼 수 있는 IntegerBox를 만들어 보자
```java
public class IntegerBox {

    private Integer value;

    public void set(Integer value) {
        this.value = value;
    }

    public Integer get() {
        return value;
    }
}
```
- 아래 코드와 같이 IntegerBox를 사용할 수 있다.
```java
    public static void main(String[] args) {
        IntegerBox integerBox = new IntegerBox();
        integerBox.set(10); //오토 박싱
        Integer integer = integerBox.get();
        System.out.println("integer = " + integer);
    }
```

- 이번엔 문자열을 저장하고 꺼낼 수 있는 StringBox를 만들어 보자
```java
public class StringBox {

    private String value;

    public void set(String object) {
        this.value = object;
    }

    public String get() {
        return value;
    }
}
```
- 아래와 같이 StringBox도 사용할 수 있다.
```java
    public static void main(String[] args) {
        IntegerBox integerBox = new IntegerBox();
        integerBox.set(10); //오토 박싱
        Integer integer = integerBox.get();
        System.out.println("integer = " + integer);

        StringBox stringBox = new StringBox();
        stringBox.set("hello");
        String str = stringBox.get();
        System.out.println("str = " + str);
    }
```
- 여기까지 코드를 살펴 보면 IntegerBox와 StringBox는 타입만
다를 뿐 전부 같은 코드인데 클래스를 새로 만들어야 하기 때문에 굉장히 
비효율적이다 라는 생각이 들 것이다.
- 모든 타입을 전부 클래스로 만들어야 한다면 굉장히 번거롭다.
- 이 문제를 제네릭을 적용하면 해결 할 수 있다.
- 이에 앞서 먼저 다형성을 통해 문제를 해결 해 보자.


# [ 다형성을 통한 중복 해결 시도 ]
- 위에서 타입이 다른것이 문제 였는데 Object를 사용하면 문제를 해결 할 수 있다.
- Object는 모든 타입의 부모 타입이기 때문이다.
```java
public class ObjectBox {

    private Object value;

    public void set(Object object) {
        this.value = object;
    }

    public Object get() {
        return value;
    }
}
```
- 위 클래스는 아래와 같이 사용할 수 있다.
```java
    public static void main(String[] args) {
        ObjectBox integerBox = new ObjectBox();
        integerBox.set(10);
        Integer integer = (Integer) integerBox.get(); //Object -> Integer 캐스팅
        System.out.println("integer = " + integer);

        ObjectBox stringBox = new ObjectBox();
        stringBox.set("hello");
        String str = (String) stringBox.get(); //Object -> Integer 캐스팅
        System.out.println("str = " + str);

        //잘못된 타입의 인수 전달시
        integerBox.set("100");
        Integer result = (Integer) integerBox.get(); // String -> Integer 캐스팅 예외
        System.out.println("result = " + result);
    }
```

- 중복은 해결이 되었지만 반환 타입이 맞지 않는 문제와 잘못된 인수를 전달 할 수 있는 문제가 있다.

###  반환 타입이 맞지 않는 문제 
- 예를들어 아래의 integerBox의 반환 타입은 Object이다.
- 따라서 Integer로 반환 받길 원한다면 캐스팅을 해줘야 한다.
```java
ObjectBox integerBox = new ObjectBox();
integerBox.set(10);
// 캐스팅 해줘야 함
Integer integer = (Integer) integerBox.get();
```

### 잘못된 타입의 인수 전달 문제
- 개발자는 이름을 integerBox로 만들어 integer 타입이 파라미터로
전달 되기를 기대했다.
- 하지만 어떠한 제한도 두지 않았기 때문에 다른 타입이 얼마든지 들어갈 수 있다.

```java
ObjectBox integerBox = new ObjectBox();
//잘못된 타입의 인수 전달시
integerBox.set("100");
Integer result = (Integer) integerBox.get(); // String -> Integer 캐스팅 예외
System.out.println("result = " + result);
```
### 정리
- Object 타입을 통해 다형성의 개념을 활용해서 코드의 중복을 제거하고
기존 코드를 재사용할 수 있게 되었다.
- 하지만 항상 다운 캐스팅을 해줘야 하며 원하지 않은 타입의 값이 들어올 수 있는
문제가 있다.
- 즉, 이 방식은 타입 안정성 ( 잘못된 타입의 데이터가 사용될 경우 프로그램이 실행되기 전 컴파일 단계에서 에러를 발생 시키는 것이 타입 안정성이 높은 것 ) 이 떨어진다.

# [ 제네릭 적용 ]
- 제네릭을 사용하면 앞선 문제 모두를 해결 하여 코드 재사용과 타입 안정성이라는
두마리 토끼를 모두 잡을 수 있다.
- `<>`를 사용한 클래스를 제네릭 클래스라고 한다.
- 해당 기호를 다이아몬드라 부르고 내부에 `T`와 같은 타입 매개변수를
적어두면 된다.
- 이렇게 하면 해당 클래스의 인스턴스를 생성하는 시점에 원하는 타입을 전달하여
타입 매개변수 자리에 전달한 타입을 지정할 수 있다.
```java
public class GenericBox<T> {

    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```
- 제네릭 클래스 사용
```java
public static void main(String[] args) {
    GenericBox<Integer> integerBox = new GenericBox<Integer>(); //생성 시점에 T의 타입 결정
    integerBox.set(10);
    //integerBox.set("문자100"); // Integer 타입만 허용, 컴파일 오류
    Integer integer = integerBox.get(); // Integer 타입 반환 (캐스팅 X)
    System.out.println("integer = " + integer);

    GenericBox<String> stringBox = new GenericBox<String>();
    stringBox.set("hello"); // String 타입만 허용
    String str = stringBox.get(); // String 타입만 반환
    System.out.println("str = " + str);

    //원하는 모든 타입 사용 가능
    GenericBox<Double> doubleBox = new GenericBox<Double>();
    doubleBox.set(10.5);
    Double doubleValue = doubleBox.get();
    System.out.println("doubleValue = " + doubleValue);

    //타입 추론: 생성하는 제네릭 타입 생략 가능
    GenericBox<Integer> integerBox2 = new GenericBox<>(); // 타입 추론:     
}
```

### 타입 추론
- 이전 코드를 보면 변수를 선언할 때와 객체를 생성할 때 <Integer> 가 두번 나온다.
- 자바는 타입 추론 기능을 제공하기 때문에 변수를 선언할 때만 타입을 적어주면
알아서 타입을 추론하기 때문제 new 키워드 다음에는 타입을 지정하지 않아도 된다.
```java
GenericBox<Integer> integerBox = new GenericBox<Integer>() // 타입 직접 입력
GenericBox<Integer> integerBox2 = new GenericBox<>() // 타입 추론
```


# [ 제네릭 용어의 관례 ]
- 제네릭의 핵심은 사용할 타입을 미리 결정하지 않는 다는 점이다.
- 클래스 내부에서 사용할 타입을 클래스 정의 시점이 아니라 생성 시점에서 결정 하는 것.


### 제네릭 ? 
- 제네릭이라는 단어는 일반적인, 범용적인이라는 뜻의 영어 단어다.
- 풀어서 해석해 보면 특정 타입에 속한 것이 아니라, 범용적으로 사용할 수 있다는 뜻

### 제네릭 타입
- 일반적으로 반환 타입과 같은 용어를 사용하는데 이때 클래스도 하나의 타입이 될 수 있다.
- 여기서 제네릭 타입이란 타입 매개변수를 사용하는 클래스나 인터페이스를 의미한다.

### 타입 매개변수
- 제네릭 타입이나 메서드에서 사용되는 변수로, 추후 실제 타입으로 대체 된다.
- GenericBox<T> 에서 T를 타입 매개변수라고 한다.

### 타입 인자
- 제네릭 타입을 사용할 때 실제 전달되는 타입을 의미한다.
- GenericBox<Integer> 라면 Integer가 타입 인자가 된다. 

### 제네릭 명명 관례
- 타입 매개변수는 일반적인 변수명처럼 소문자로 사용해도 문제는 없다.
  하지만 일반적으로 대문자를 사용하고 용도에 맞는 단어의 첫글자를 사용하는 관례를 따른다.
- 주로 사용하는 키워드는 다음과 같다.
  - E - Element
  - K - Key
  - N - Number
  - T - Type
  - V - Value
  - S,U,V etc. - 2nd, 3rd, 4th types

### 제네릭 기타
- 아래와 같이 한번에 여러 타입 매개변수를 선언할 수도 있다.
```java
class Data<K,V> {}
```
- 제네릭의 타입 인자로 기본형 ( int, double )은 사용할 수 없다. 래퍼 클래스 (Integer, Double)을 사용해야 한다.
그 이유는 자바에서 제네릭의 경우 데이터를 Object로 바꾸어 관리하는데 기본 타입은 객체가 아니라서 
Object를 상속 받지 않기에 타입 인자로 사용할 수 없는 것.

### Raw 타입
- 제네릭 타입을 사용할 때는 항상 `<>` 를 사용해서 사용시점에 원하는 타입을 지정해야 한다.
  그런데 아래와 같이 `<>` 을 지정하지 않을 수 있는데, 이런 것을 로 타입(raw type), 또는 원시 타입이라한다.
- 이 경우 타입 매개 변수가 Object가 된다고 이해하면 된다.
- 제네릭이 자바가 처음 등장할 때 부터 있었던 것이 아니라 자바가 오랜기간 사용된 이후에 등장했기 때문에 제네
  릭이 없던 시절의 과거 코드와의 하위 호환이 필요했다. 그래서 어쩔 수 없이 이런 로 타입을 지원한다.
- 정리하면 로 타입을 사용하지 않아야 한다.
  만약에 `Object` 타입을 사용해야 한다면 다음과 같이 타입 인자로 `Object` 를 지정해서 사용하면 된다.
```java
public static void main(String[] args) {
    GenericBox integerBox = new GenericBox();
    //GenericBox<Object> integerBox = new GenericBox<>(); // 권장
    integerBox.set(10);
    Integer result = (Integer) integerBox.get();
    System.out.println("result = " + result);
}
```


# [ 제네릭 활용 예제 ]
- Animal 클래스 생성
```java
public class Animal {

    private String name;
    private int size;

    public Animal(String name, int size) {
        this.name = name;
        this.size = size;
    }

    public String getName() {
        return name;
    }

    public int getSize() {
        return size;
    }

    public void sound() {
        System.out.println("동물 울음 소리");
    }

    @Override
    public String toString() {
        return "Animal{" +
                "name='" + name + '\'' +
                ", size=" + size +
                '}';
    }
}
```

- 위 클래스를 상속받는 Dog, Cat 클래스를 만든다.

```java
public class Cat extends Animal {

    public Cat(String name, int size) {
        super(name, size);
    }

    @Override
    public void sound() {
        System.out.println("냐옹");
    }
}


public class Dog extends Animal {

    public Dog(String name, int size) {
        super(name, size);
    }

    @Override
    public void sound() {
        System.out.println("멍멍");
    }

}

```

- 이제 객체를 보관할 수 있도록 제네릭 박스를 하나 만든다.

```java
public class Box<T> {
    private T value;
    
    public void set(T value) {
        this.value = value;
    }
    
    public T get() {
        return value;
    }
}
```

- 사용 예제
```java
    public static void main(String[] args) {
    Animal animal = new Animal("동물", 0);
    Dog dog = new Dog("멍멍이", 100);
    Cat cat = new Cat("냐옹이", 50);

    Box<Dog> dogBox = new Box<>();
    dogBox.set(dog);
    Dog findDog = dogBox.get();
    System.out.println("findDog = " + findDog);

    Box<Cat> catBox = new Box<>();
    catBox.set(cat);
    Cat findCat = catBox.get();
    System.out.println("findCat = " + findCat);

    Box<Animal> animalBox = new Box<>();
    animalBox.set(animal);
    Animal findAnimal = animalBox.get();
    System.out.println("findAnimal = " + findAnimal);
}


// 출력 결과
findDog = Animal{name='멍멍이', size=100}
findCat = Animal{name='냐옹이', size=50}
findAnimal = Animal{name='동물', size=0}

```

- 여기서 Box<Animal>의 경우 타입 매개변수에 Animal을 대입하면 아래와 같다

```java
public class Box<Animal> {
    private Animal value;
    
    public void set(Animal value) {
    this.value = value;
    }
    
    public Animal get() {
    return value;
    }
}
```
- 위의 경우 set의 Animal의 하위 타입인 Dog와 Cat도 전달할 수 있다.
```java

public class AnimalMain2 {

    public static void main(String[] args) {
        Animal animal = new Animal("동물", 0);
        Dog dog = new Dog("멍멍이", 100);
        Cat cat = new Cat("냐옹이", 50);

        Box<Animal> animalBox = new Box<>();
        animalBox.set(animal);
        animalBox.set(dog); // Animal = Dog
        animalBox.set(cat); // Animal = Cat
        Animal findAnimal = animalBox.get();
        System.out.println("findAnimal = " + findAnimal);
    }
}

// 실행 결과
findAnimal = Animal{name='냐옹이', size=50}
```


# [ 타입 매개변수 제한 ]

### 생성자에 인자로 받을 타입 지정
- 먼저 특정 타입을 인자로 받는 클래스를 만들어 보자
```java

// Cat 클래스만 받는 클래스
public class CatHospital {

  private Cat animal;

  public void set(Cat animal) {
    this.animal = animal;
  }

  public void checkup() {
    System.out.println("동물 이름: " + animal.getName());
    System.out.println("동물 크기: " + animal.getSize());
    animal.sound();
  }

  public Cat getBigger(Cat target) {
    return animal.getSize() > target.getSize() ? animal : target;
  }
}

// Dog 클래스만 받는 클래스
public class DogHospital {

  private Dog animal;

  public void set(Dog animal) {
    this.animal = animal;
  }

  public void checkup() {
    System.out.println("동물 이름: " + animal.getName());
    System.out.println("동물 크기: " + animal.getSize());
    animal.sound();
  }

  public Dog bigger(Dog target) {
    return animal.getSize() > target.getSize() ? animal : target;
  }
}

```

- 위 클래스를 사용해 보자
```java
public class AnimalHospitalMainV0 {

  public static void main(String[] args) {
    DogHospital dogHospital = new DogHospital();
    CatHospital catHospital = new CatHospital();

    Dog dog = new Dog("멍멍이1", 100);
    Cat cat = new Cat("냐옹이1", 300);

    // 개 병원
    dogHospital.set(dog);
    dogHospital.checkup();

    // 고양이 병원
    catHospital.set(cat);
    catHospital.checkup();

    // 문제1: 개 병원에 고양이 전달
    // dogHospital.checkup(cat); // 다른 타입 입력: 컴파일 오류

    // 문제2: 개 타입 반환
    dogHospital.set(dog);
    Dog biggerDog = dogHospital.bigger(new Dog("멍멍이2", 200));
    System.out.println("biggerDog = " + biggerDog);
  }
}

```

- 위의 결과를 보면 각각의 클래스가 원하는 타입의 인자만 전달 받도록 잘 동작한다.
- 타입 안정성은 명확히 지켜졌지만 각각의 클래스가 서로 중복된 코드가 너무 많다.

### 다형성 시도
- 위에서 사용된 Dog, Cat클래스는 Animal을 상속 받고 있다.
- 따라서 인자의 타입을 생성자 매개변수의 타입을 Animal로 하면 다형성을 통해 
하나의 클래스에서 Dog와 Cat을 모두 받을 수 있다.

```java
public class AnimalHospitalV1 {

    private Animal animal;

    public void set(Animal animal) {
        this.animal = animal;
    }

    public void checkup() {
        System.out.println("동물 이름: " + animal.getName());
        System.out.println("동물 크기: " + animal.getSize());
        animal.sound();
    }

    public Animal getBigger(Animal target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }
}
```

- 위 클래스를 사용해 보자.
```java
public class AnimalHospitalMainV1 {

  public static void main(String[] args) {
    AnimalHospitalV1 dogHospital = new AnimalHospitalV1();
    AnimalHospitalV1 catHospital = new AnimalHospitalV1();

    Dog dog = new Dog("멍멍이1", 100);
    Cat cat = new Cat("냐옹이1", 300);

    // 개 병원
    dogHospital.set(dog);
    dogHospital.checkup();

    // 고양이 병원
    catHospital.set(cat);
    catHospital.checkup();

    // 문제1: 개 병원에 고양이 전달
    dogHospital.set(cat); // 매개변수 체크 실패: 컴파일 오류가 발생하지 않음

    // 문제2: 개 타입 반환, 캐스팅 필요
    dogHospital.set(dog);
    Dog biggerDog = (Dog) dogHospital.getBigger(new Dog("멍멍이2", 200));
    System.out.println("biggerDog = " + biggerDog);
  }
} 
```
- 위의 결과를 보면 다형성을 통해 코드 재사용성은 높아졌지만
타입 안정성이 떨어지는 걸 알 수 있다.
- 의도와는 다른 타입을 전달할 수 도 있고 , 특정 타입으로 다운캐스팅을 해줘야 하는 문제도 있으며 이 과정에서
캐스팅 예외도 발생할 수 있다.

### 제네릭 도입
- 제네릭을 도입하면 재사용성을 늘리고, 타입 안정성도 높일 수 있을까?
```java
public class AnimalHospitalV2<T> {

  private T animal;

  public void set(T animal) {
    this.animal = animal;
  }

  public void checkup() {
    // T의 타입을 메서드를 정의하는 시점에는 알 수 없다. Object의 기능만 사용 가능
    animal.toString();
    animal.equals(null);

    // 컴파일 오류
    //System.out.println("동물 이름: " + animal.getName());
    //animal.sound();
  }

  public T getBigger(T target) {
    // 컴파일 오류
    //return animal.getSize() > target.getSize() ? animal : target;
    return null;
  }
} 
```

- 위의 코드처럼 단순히 제네릭을 적용하면 컴파일 에러가 발생한다.
- 자바 컴파일러는 타입 매개변수를 Object타입으로 가정한다.
- 따라서 Animal과 그 자식들을 인자로 전달할 수는 있겠지만
그 기능들을 사용할 수 있도록 정의 해 둘 수 없다.
- 또한 Integer같은 전혀 관계 없는 타입도 전부 인자로 전달 받을 수 있다는 문제도 있다. 
- 이 문제를 해결하는 방법은 제네릭을 사용하되 타입 매개변수를 제한하는 것이다.

### 타입 매개변수 제한
- 타입 매개변수를 특정 타입으로 제한할 수 있다.

```java
public class AnimalHospitalV3<T extends Animal> {

    private T animal;

    public void set(T animal) {
        this.animal = animal;
    }

    public void checkup() {
        System.out.println("동물 이름: " + animal.getName());
        System.out.println("동물 크기: " + animal.getSize());
        animal.sound();
    }

    public T getBigger(T target) {
        return animal.getSize() > target.getSize() ? animal : target;
    }

}
```

- 위의 코드처럼 타입이 Animal클래스를 상속받게 되면 해당 클래스와 자식만 타입으로 전달 받을 수 있다.
- 따라서 자바 컴파일러는 T에 입력될 수 있는 값을 예측 할 수 있어 해당 클래스들의 메서드를 사용할 수 있게 된다.
- 위 클래스를 사용해 보자.
```java
public class AnimalHospitalMainV3 {

  public static void main(String[] args) {
    AnimalHospitalV3<Dog> dogHospital = new AnimalHospitalV3<>();
    AnimalHospitalV3<Cat> catHospital = new AnimalHospitalV3<>();
    String name = Object.class.getName();
    Dog dog = new Dog("멍멍이1", 100);
    Cat cat = new Cat("냐옹이1", 300);

    //개 병원
    dogHospital.set(dog);
    dogHospital.checkup();

    //고양이 병원
    catHospital.set(cat);
    catHospital.checkup();

    // 문제1 해결: 개 병원에 고양이 전달
    // dogHospital.set(cat); // 다른 타입 입력: 컴파일 오류

    // 문제2 해결: 개 타입 반환
    dogHospital.set(dog);
    Dog biggerDog = dogHospital.getBigger(new Dog("멍멍이2", 200));
    System.out.println("biggerDog = " + biggerDog);
  }
}


// 출력 결과
동물 이름: 멍멍이1
동물 크기: 100
멍멍
동물 이름: 냐옹이1
동물 크기: 300
냐옹
        biggerDog = Animal{name='멍멍이2', size=200}
```
### 제네릭 타입 매개변수 제한을 통한 문제 해결
- 타입 안전성이 떨어지는 문제
  - 개 병원에 고양이를 전달하는 문제가 발생한다. -> 해결
  - `Animal` 타입을 반환하기 때문에 다운 캐스팅을 해야 한다. -> 해결
  - 실수로 고양이를 입력했는데, 개를 반환하는 상황이라면 캐스팅 예외가 발생한다. -> 해결
- **제네릭 도입 문제**
  - 제네릭에서 타입 매개변수를 사용하면 어떤 타입이든 들어올 수 있다. -> 해결
  - 그리고 어떤 타입이든 수용할 수 있는 `Object` 로 가정하고, `Object` 의 기능만 사용할 수 있다. -> 해결
  - 여기서는 `Animal` 을 상한으로 두어서 `Animal` 의 기능을 사용할 수 있다.
- **정리**
  - 제네릭에 **타입 매개변수 상한**을 사용해서 타입 안전성을 지키면서 상위 타입의 원하는 기능까지 사용할 수 있었다. 덕분
  에 코드 재사용과 타입 안전성이라는 두 마리 토끼를 동시에 잡을 수 있었다.


# [ 제네릭 메서드 ]
### 제네릭 메서드 기본 문법
- 제네릭 메서드는 반환 타입 앞에 타입 매개변수를 선언해야 한다.
```java
public <T> 반환타입 메서드명(T 매개변수) {
    // 메서드 본문
}
```

- 제네릭 메서드가 포함된 클래스를 만들어 보자
```java
public class GenericMethod {

  public static Object objMethod(Object obj) {
    System.out.println("object print: " + obj);
    return obj;
  }

  public static <T> T genericMethod(T t) {
    System.out.println("generic print: " + t);
    return t;
  }

  // 제네릭 메서드도 타입 매개변수 제한을 설정할 수 있다.
  public static <T extends Number> T numberMethod(T t) {
    System.out.println("bound print: " + t);
    return t;
  }
} 
```

- 위 클래스를 사용해 보자.
```java
public class MethodMain1 {

  public static void main(String[] args) {
    Integer i = 10;
    Object object = GenericMethod.objMethod(i);

    // 타입 인자(Type Argument) 명시적 전달
    System.out.println("명시적 타입 인자 전달");
    Integer result = GenericMethod.<Integer>genericMethod(i);
    Integer integerValue = GenericMethod.<Integer>numberMethod(10);
    Double doubleValue = GenericMethod.<Double>numberMethod(20.0);
    
  }
}

// 출력 결과

명시적 타입 인자 전달
generic print: 10
bound print: 10
bound print: 20.0

타입 추론
generic print: 10
bound print: 10
bound print: 20.0
```

- 제네릭 메서드는 클래스 전체가 아니라 특정 메서드 단위로 제네릭을 도입할 때 사용한다.
- 제네릭 메서드를 정의할 때는 메서드의 반환 타입 왼쪽에 다이아몬드를 사용해서 `<T>` 와 같이 타입 매개변수를
  적어준다.
- 제네릭 메서드는 메서드를 실제 호출하는 시점에 다이아몬드를 사용해서 `<Integer>` 와 같이 타입을 정하고 호출한다.

### 인스턴스 메서드, static 메서드
- 제네릭 메서드는 인스턴스 메서드와 static 메서드에 모두 적용할 수 있다.
```java
 class Box<T> { //제네릭 타입
  static <V> V staticMethod2(V t) {} //static 메서드에 제네릭 메서드 도입
  <Z> Z instanceMethod2(Z z) {} //인스턴스 메서드에 제네릭 메서드 도입 가능
}
```
- 주의할 점은 static메서드의 경우 제네릭 타입의 타입 매개변수를 사용할 수 없다는 것이다.
- 제네릭 타입은 객체를 생성하는 시점에 타입이 정해지는데 static 메서드는
인스턴스 단위가 아니라 클래스 단위로 작동하기 때문에 컴파일 시점에 타입을 알 수 없게 된다.
- 따라서 static 메서드에 제네릭을 적용하려면 메서드 자체를 제네릭 메서드로 사용해야 한다.
```java
class Box<T> {
  T instanceMethod(T t) {} //가능
  static T staticMethod1(T t) {} //제네릭 타입의 T 사용 불가능
} 
```

### 제네릭 메서드 타입 매개변수 제한
- 제네릭 메서드도 제네릭 타입과 마찬가지로 타입 매개변수를 제한할 수 있다.
```java
// 정의 
public static <T extends Number> T numberMethod(T t) {}


// 사용 예제
GenericMethod.numberMethod("Hello"); // 컴파일 오류 Number의 자식만 입력 가능

```

### 제네릭 메서드 타입 추론
- 제네릭 메서드를 호출할 때 `<Integer>` 와 같이 타입 인자를 계속 전달하는 것은 매우 불편하다
```java
Integer result = GenericMethod.<Integer>genericMethod(10); 
```
- 자바 컴파일러는 `genericMethod()` 에 전달되는 인자 `i` 의 타입이 `Integer` 라는 것을 알 수 있다.
  또한 반환 타입이 `Integer result` 라는 것도 알 수 있다. 
- 이런 정보를 통해 자바 컴파일러는 타입 인자를 추론할 수
  있다.
```java

public class MethodMain1 {

  public static void main(String[] args) {
    Integer i = 10;
    Object object = GenericMethod.objMethod(i);

    
    System.out.println("명시적 타입 인자 전달");
    Integer result = GenericMethod.<Integer>genericMethod(i);
    Integer integerValue = GenericMethod.<Integer>numberMethod(10);
    Double doubleValue = GenericMethod.<Double>numberMethod(20.0);

    //타입 추론, 타입 인자 생략
    System.out.println("타입 추론");
    Integer result2 = GenericMethod.genericMethod(i);
    Integer integerValue2 = GenericMethod.numberMethod(10);
    Double doubleValue2 = GenericMethod.numberMethod(20.0);
  }
}

//추가한 내용만 출력
// 타입 추론
generic print: 10
bound print: 10
bound print: 20.0
```
- 타입 추론 덕분에 타입 인자를 직접 전달하는 불편함이 줄어든다. 
- 이 경우 타입을 추론해서 컴파일러가 대신 처리하기 때문에 타입을 전달하지 않는 것 처럼 보인다. 
- 하지만 실제로는 타입 인자가 전달된다.

# [ 제네릭 메서드 활용 ]
- 앞서 **제네릭 타입**으로 만들었던 `AnimalHospitalV3` 의 주요 기능을 **제네릭 메서드**로 다시 만들어보자.
```java
public class AnimalMethod {

  public static <T extends Animal> void checkup(T t) {
    System.out.println("동물 이름: " + t.getName());
    System.out.println("동물 크기: " + t.getSize());
    t.sound();
  }

  public static <T extends Animal> T getBigger(T t1, T t2) {
    return t1.getSize() > t2.getSize() ? t1 : t2;
  }

} 
```
- 위 클래스를 사용해 보자.
```java
public class MethodMain2 {

  public static void main(String[] args) {
    Dog dog = new Dog("멍멍이", 100);
    Cat cat = new Cat("냐옹이", 100);

    AnimalMethod.checkup(dog);
    AnimalMethod.checkup(cat);

    Dog targetDog = new Dog("큰 멍멍이", 200);
    Dog bigger = AnimalMethod.getBigger(dog, targetDog);
    System.out.println("bigger = " + bigger);
  }
}

// 출력 결과
동물 이름: 멍멍이
동물 크기: 100
멍멍
동물 이름: 냐옹이
동물 크기: 100
냐옹
bigger = Animal{name='큰 멍멍이', size=200}

```
- 기존 코드와 같이 작동하는 것을 확인할 수 있다.
- 참고로 제네릭 메서드를 호출할 때 타입 추론을 사용했다.

### 제네릭 타입과 제네릭 메서드의 우선 순위
- static 메서드는 제네릭 메서드만 적용할 수 있지만, 인스턴스 메서드는 제네릭 타입, 제네릭 머서드를 함께 적용할 수 있다.
- 이때 제네릭 타입 보다 제네릭 메서드가 우선순위를 가진다.
```java
public class ComplexBox<T extends Animal> {

  private T animal;

  public void set(T animal) {
    this.animal = animal;
  }

  /**
   * 클래스 레벨의 제네릭 타입보다 제네릭 메서드가 우선순위를 가진다.
   * 아래의 T타입은 클래스 생성시 전달한 타입과는 상관없이 메서드를 호출 할 때 받는 파라미터 타입으로
   * 결졍된다.
   */
  public <T> T printAndReturn(T t) {
    System.out.println("animal.className: " + animal.getClass().getName());
    System.out.println("t.className: " + t.getClass().getName());
    // t.getName(); // 호출 불가다. 왜냐하면 메서드는 <T> 타입이다. <T extends Animal> 타입이 아니다.
    return t;
  }

} 
```
- 위 클래스를 사용해 보자.
```java
public class MethodMain3 {

  public static void main(String[] args) {
    Dog dog = new Dog("멍멍이", 100);
    Cat cat = new Cat("냐옹이", 50);

    ComplexBox<Dog> hospital = new ComplexBox<>();
    hospital.set(dog);

    Cat returnCat = hospital.printAndReturn(cat);
    System.out.println("returnCat = " + returnCat);
  }
} 
// 실행 결과
animal.className: generic.animal.Dog
t.className: generic.animal.Cat
returnCat = Animal{name='냐옹이', size=50}
```
- 위의 결과 처럼 제네릭 메서드가 제네릭 타입보다 우선순위를 가지기 때문에 
printAndReturn()은 제네릭 타입 과는 무관하게 제네릭 메서드로 동작한다.
- 참고로 이렇게 모호한 것은 프로그래밍에서 좋지 않다.
- 둘의 이름이 겹치면 아래와 같이 서로 다른 이름으로 변경하는 것이 좋다.
```java
 public class ComplexBox<T extends Animal> {
    private T animal;
    
    public void set(T animal) {
      this.animal = animal;
    }
    
    public <Z> Z printAndReturn(Z z) {
  //...
    }
}
```
# 와일드 카드
- 제네릭 타입을 조금 더 편리하게 사용할 수 있는 와일드카드(wildcard)라는 것이 있다.
- 와일드카드라는 뜻은 컴퓨터 프로그래밍에서 `*` , `?` 와 같이 하나 이상의 문자들을 상징하는 특수 문자를 뜻한다.
- 쉽게 이야기해서 여러 타입이 들어올 수 있다는 뜻이다.

### 비제한 와일드 카드

- 먼저 단순히 데이터를 넣고 반환할 수 있는 제네릭 타입을 만들어 보자
```java
 public class Box<T> {

  private T value;

  public void set(T value) {
    this.value = value;
  }

  public T get() {
    return value;
  }

}
```
- 와일드 카드는 제네릭 타입이나, 제네릭 메서드를 선언할 때 활용하는 것이 아니라
이미 만들어진 제네릭 타입을 활용할 때 사용하는 것이다.
- 제네릭 메서드와 와일드 카드를 비교할 수 있게 같은 기능을 각각 하나씩 배치하여 클래스를 만들어 보자
```java
 public class WildcardEx {

  static <T> void printGenericV1(Box<T> box) {
    System.out.println("T = " + box.get());
  }

  static void printWildcardV1(Box<?> box) {
    System.out.println("? = " + box.get());
  }

  static <T extends Animal> void printGenericV2(Box<T> box) {
    T t = box.get();
    System.out.println("이름 = " + t.getName());
  }

  static void printWildcardV2(Box<? extends Animal> box) {
    Animal animal = box.get();
    System.out.println("이름 = " + animal.getName());
  }

  static <T extends Animal> T printAndReturnGeneric(Box<T> box) {
    T t = box.get();
    System.out.println("이름 = " + t.getName());
    return t;
  }

  static Animal printAndReturnWildcard(Box<? extends Animal> box) {
    Animal animal = box.get();
    System.out.println("이름 = " + animal.getName());
    return animal;
  }
}
```
- 위 클래스를 사용해 보자
```java
 public class WildcardMain1 {

  public static void main(String[] args) {
    Box<Object> objBox = new Box<>();
    Box<Dog> dogBox = new Box<>();
    Box<Cat> catBox = new Box<>();
    dogBox.set(new Dog("멍멍이", 100));

    WildcardEx.printGenericV1(dogBox);
    WildcardEx.printWildcardV1(dogBox);

    WildcardEx.printGenericV2(dogBox);
    WildcardEx.printWildcardV2(dogBox);

    Dog dog = WildcardEx.printAndReturnGeneric(dogBox);
    Animal animal = WildcardEx.printAndReturnWildcard(dogBox);
  }

}

// 실행 결과
T = Animal{name='멍멍이', size=100}
? = Animal{name='멍멍이', size=100}
이름 = 멍멍이
        이름 = 멍멍이
이름 = 멍멍이
        이름 = 멍멍이
```
- 위의 결과를 보면 제네릭 메서드와 와일드 카드의 기능이 거의 똑같은데 왜 쓰는건지 의문이 들 수 있다.
- 와일드 카드는 단순히 메서드 내부에서 타입 매개변수를 사용할 일 이 없고, 호출하는 곳에서도 호출시 전달한 타입을 반환 받을 필요가 없을때
코드를 더 가독성 좋게 작성하기 위해서 사용하는 것이다.
- 추가적인 기능이 하나 있는데 그것은 상속관계를 더 넓게 수용한다는 점이다.
- 제네릭 메서드는 extends를 통해 타입 매개변수의 상한만 정할 수 있지만 와일드 카드는 super 키워드를 통해 하한도 정할 수 있다.

### 상한 와일드 카드
- 제네릭 메서드와 마찬가지로 와일드카드에도 상한 제한을 둘 수 있다.
```java
    static <T extends Animal> void printGenericV2(Box<T> box) {
  T t = box.get();
  System.out.println("이름 = " + t.getName());
}

static void printWildcardV2(Box<? extends Animal> box) {
  Animal animal = box.get();
  System.out.println("이름 = " + animal.getName());
} 
```
### 와일드 카드를 사용하면 안되는 경우
- 타입 매개변수가 꼭 필요하다면 와일드 카드를 사용하면 안되고 제네릭 메서드를 사용해야 한다.
- 와일드 카든느 제네릭을 정의할 때 사용하는 것이 아니기 때문에 인자로 전달 받은 타입을 내부에서 활용할 수 없기 때문이다.
```java
// Dog dog = WildcardEx.printAndReturnGeneric(dogBox) 이렇게 전달한 타입을 반환 받을 수 있다.
static <T extends Animal> T printAndReturnGeneric(Box<T> box) {
  T t = box.get();
  System.out.println("이름 = " + t.getName());
  return t;
}
// 반면에 `printAndReturnWildcard()` 의 경우 전달한 타입을 명확하게 반환할 수 없다. 
// 여기서는 `Animal` 타입으로 반환한다.
static Animal printAndReturnWildcard(Box<? extends Animal> box) {
  Animal animal = box.get();
  System.out.println("이름 = " + animal.getName());
  return animal;
} 
```
- 정리하면 메서드 타입들을 사용 시점에 변경하려면 반드시 제네릭 타입이나, 제네릭 메서드를 활용해야 한다.
- 따라서 제네릭 타입이나 제네릭 메서드가 꼭 필요한 상황이면 <T>를 사용하고 그렇지 않으면 와일드 카드를 사용하는 것이 권장된다.

### 하한 와일드 카드
- 와일드카드는 상한 뿐만 아니라 하한도 지정할 수 있다.
```java
public class WildcardMain2 {

  public static void main(String[] args) {
    Box<Object> objBox = new Box<>();
    Box<Animal> animalBox = new Box<>();
    Box<Dog> dogBox = new Box<>();
    Box<Cat> catBox = new Box<>();

    // Animal 포함 상위 타입 전달 가능
    writeBox(objBox);
    writeBox(animalBox);
    //writeBox(dogBox); // 하한을 `Animal` 로 제한했기 때문에 `Animal` 타입의 하위 타입인 `Box<Dog>` 는 전달할 수 없다.
    //writeBox(catBox); // 하한이 Animal

    Animal animal = animalBox.get();
    System.out.println("animal = " + animal);
  }
// 이 코드는 `?` 가 `Animal` 타입을 포함한 `Animal` 타입의 상위 타입만 입력 받을 수 있다는 뜻이다.
  static void writeBox(Box<? super Animal> box) {
    box.set(new Dog("멍멍이", 100));
  }
} 
```

# 타입 이레이저
- 제네릭은 자바 컴파일 단계에서만 사용되고, 컴파일 이후에는 제네릭 정보가 삭제된다.
- 제네릭에 사용한 타입 매개변수가 모두 사라지는 것이다.
- `.java` 에는 제네릭의 타입 매개변수가 존재하지만, 컴파일 이후인 자바 바이트코드 `.class` 에는 타입 매개변수가 존재하지 않는 것이다.
- 그 이유는 제네릭이 도입되기 전 코드와 도입 후 코드의 호환성을 위해서이다.
- 타입이 어떻게 삭제되는지 알아  보자

### 제네릭 타입 선언 후 컴파일 단계
```java
public class GenericBox<T> {
  private T value;
  
  public void set(T value) {
    this.value = value;
  }
  
  public T get() {
    return value;
  }
}

```
- 위 제네릭 타입에 Integer 타입 전달

```java
void main() {
  GenericBox<Integer> box = new GenericBox<Integer>();
  box.set(10);
  Integer result = box.get();
}
```
- 위와 같이 타입을 전달하면 컴파일러로는 아래 코드로 인식 하고 컴파일을 진행한다.

```java
public class GenericBox<Integer> {
  private Integer value;
  
  public void set(Integer value) {
    this.value = value;
  }
  
  public Integer get() {
    return value;
  }
}
```

### 컴파일 완료 이후
- 컴파일이 모두 완료 되면 제네릭과 관련된 정보를 삭제한다.
- 이때 상한 제한 없이 선언한 타입 매개변수는 Object로 변환된다.

```java
public class GenericBox {
  private Object value;
  
  public void set(Object value) {
    this.value = value;
  }
  
  public Object get() {
    return value;
  }
}
```

- 이렇게 되면 기존에 해당 클래스를 사용하던 곳에서 Integer 타입으로 반환받았기 때문에 에러가 난다.
- 따라서 타입이 지워지기 전에 존재하던 타입으로 캐스팅을 한다.
- 캐스팅을 해도 아무런 문제가 없는 이유는 컴파일 단계에서 이미 제네릭에 어떤 타입이 전달되었는지 모두 확인했기 때문에
캐스팅을 해도 아무런 문제가 발생하지 않는 것이다.
```java
void main() {
GenericBox box = new GenericBox();
box.set(10);
Integer result = (Integer) box.get(); //컴파일러가 캐스팅 추가
}
```
### 타입 매개변수 제한의 경우
- extends를 통해 타입 매개변수를 제한했었다면 컴파일 후 Object가 아닌 제한 타입으로 대체 된다.

```java
public class AnimalHospitalV3<T extends Animal> {
  private T animal;
  
  public void set(T animal) {
    this.animal = animal;
  }
  
  public void checkup() {
    System.out.println("동물 이름: " + animal.getName());
    System.out.println("동물 크기: " + animal.getSize());
    animal.sound();
  }
  
  public T getBigger(T target) {
    return animal.getSize() > target.getSize() ? animal : target;
  }
}
```
- 위 클래스가 컴파일이 되면 아래 처럼 된다.
-   T` 의 타입 정보가 제거되어도 상한으로 지정한 `Animal` 타입으로 대체되기 때문에 `Animal` 타입의 메서드를
  사용하는데는 아무런 문제가 없다.
```java
public class AnimalHospitalV3 {
  private Animal animal;
  
  public void set(Animal animal) {
    this.animal = animal;
  }
  
  public void checkup() {
    System.out.println("동물 이름: " + animal.getName());
    System.out.println("동물 크기: " + animal.getSize());
    animal.sound();
  }
  
  public Animal getBigger(Animal target) {
    return animal.getSize() > target.getSize() ? animal : target;
  }
}
```
- 위 코드도 마찬가지로 컴파일 후 자바가 캐스팅 코드를 넣어준다.

```java
AnimalHospitalV3 hospital = new AnimalHospitalV3();
...
Dog dog = (Dog) animalHospitalV3.getBigger(new Dog());
```

- 이처럼 제네릭은 단순하게 생각하면 개발자가 직접 캐스팅 하는 코드를 컴파일러가 대신 처리해주는 것이다.
- 자바는 컴파일 시점에 제네릭을 사용한 코드에 문제가 없는지 완벽하게 검증하기 때문에 다운 캐스팅 시 아무런 문제가 발생하니 않는다.
- 자바의 제네릭 타입 매개변수는 컴파일 시점에만 존재하고 런타임 시에는 제네릭 정보가 지워지는데 이것을 타입 이레이저라고 한다.

### 타입 이레이저 방식의 한계
- 컴파일 이후에는 제네릭의 타입 정보가 존재하지 않기 대문에 아래와 같은 코드는 작성할 수 없다.

```java
class EraserBox<T> {
    
  public boolean instanceCheck(Object param) {
    return param instanceof T; // 오류
  }
  public T create() {
    return new T(); // 오류
  }
}
```
- 먼저 instanceCheck 메서드를 살펴보면 
JVM 입장에서는 param instanceof T를 param instanceof Object로 해석해야 할지, 아니면 사용자가 의도한 특정 타입으로 해석해야 할지 알 방법이 없다. 
- 자바 설계자들은 불확실한 동작을 막기 위해 이를 컴파일 오류로 처리했다.
- create메서드를 살펴보면 바 컴파일러는 런타임에 어떤 타입이 올지 보장할 수 없으므로, 타입 파라미터로 인스턴스를 직접 생성하는 것을 금지한다.