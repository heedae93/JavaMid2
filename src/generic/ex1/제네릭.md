# [ 제네릭이 필요한 이유 ]
- 먼저 숫자를 보관하고 꺼낼 수 있는 IntegerBox를 만들어 보자
```java
public class IntegerBox {

    private Integer value;

    public void set(Integer value) {
        this.value = value;
    }

    public Integer get() {
        return value;
    }
}
```
- 아래 코드와 같이 IntegerBox를 사용할 수 있다.
```java
    public static void main(String[] args) {
        IntegerBox integerBox = new IntegerBox();
        integerBox.set(10); //오토 박싱
        Integer integer = integerBox.get();
        System.out.println("integer = " + integer);
    }
```

- 이번엔 문자열을 저장하고 꺼낼 수 있는 StringBox를 만들어 보자
```java
public class StringBox {

    private String value;

    public void set(String object) {
        this.value = object;
    }

    public String get() {
        return value;
    }
}
```
- 아래와 같이 StringBox도 사용할 수 있다.
```java
    public static void main(String[] args) {
        IntegerBox integerBox = new IntegerBox();
        integerBox.set(10); //오토 박싱
        Integer integer = integerBox.get();
        System.out.println("integer = " + integer);

        StringBox stringBox = new StringBox();
        stringBox.set("hello");
        String str = stringBox.get();
        System.out.println("str = " + str);
    }
```
- 여기까지 코드를 살펴 보면 IntegerBox와 StringBox는 타입만
다를 뿐 전부 같은 코드인데 클래스를 새로 만들어야 하기 때문에 굉장히 
비효율적이다 라는 생각이 들 것이다.
- 모든 타입을 전부 클래스로 만들어야 한다면 굉장히 번거롭다.
- 이 문제를 제네릭을 적용하면 해결 할 수 있다.
- 이에 앞서 먼저 다형성을 통해 문제를 해결 해 보자.


# [ 다형성을 통한 중복 해결 시도 ]
- 위에서 타입이 다른것이 문제 였는데 Object를 사용하면 문제를 해결 할 수 있다.
- Object는 모든 타입의 부모 타입이기 때문이다.
```java
public class ObjectBox {

    private Object value;

    public void set(Object object) {
        this.value = object;
    }

    public Object get() {
        return value;
    }
}
```
- 위 클래스는 아래와 같이 사용할 수 있다.
```java
    public static void main(String[] args) {
        ObjectBox integerBox = new ObjectBox();
        integerBox.set(10);
        Integer integer = (Integer) integerBox.get(); //Object -> Integer 캐스팅
        System.out.println("integer = " + integer);

        ObjectBox stringBox = new ObjectBox();
        stringBox.set("hello");
        String str = (String) stringBox.get(); //Object -> Integer 캐스팅
        System.out.println("str = " + str);

        //잘못된 타입의 인수 전달시
        integerBox.set("100");
        Integer result = (Integer) integerBox.get(); // String -> Integer 캐스팅 예외
        System.out.println("result = " + result);
    }
```

- 중복은 해결이 되었지만 반환 타입이 맞지 않는 문제와 잘못된 인수를 전달 할 수 있는 문제가 있다.

###  반환 타입이 맞지 않는 문제 
- 예를들어 아래의 integerBox의 반환 타입은 Object이다.
- 따라서 Integer로 반환 받길 원한다면 캐스팅을 해줘야 한다.
```java
ObjectBox integerBox = new ObjectBox();
integerBox.set(10);
// 캐스팅 해줘야 함
Integer integer = (Integer) integerBox.get();
```

### 잘못된 타입의 인수 전달 문제
- 개발자는 이름을 integerBox로 만들어 integer 타입이 파라미터로
전달 되기를 기대했다.
- 하지만 어떠한 제한도 두지 않았기 때문에 다른 타입이 얼마든지 들어갈 수 있다.

```java
ObjectBox integerBox = new ObjectBox();
//잘못된 타입의 인수 전달시
integerBox.set("100");
Integer result = (Integer) integerBox.get(); // String -> Integer 캐스팅 예외
System.out.println("result = " + result);
```
### 정리
- Object 타입을 통해 다형성의 개념을 활용해서 코드의 중복을 제거하고
기존 코드를 재사용할 수 있게 되었다.
- 하지만 항상 다운 캐스팅을 해줘야 하며 원하지 않은 타입의 값이 들어올 수 있는
문제가 있다.
- 즉, 이 방식은 타입 안정성이 떨어진다.

# [ 제네릭 적용 ]
- 제네릭을 사용하면 앞선 문제 모두를 해결 하여 코드 재사용과 타입 안정성이라는
두마리 토끼를 모두 잡을 수 있다.
- `<>`를 사용한 클래스를 제네릭 클래스라고 한다.
- 해당 기호를 다이아몬드라 부르고 내부에 `T`와 같은 타입 매개변수를
적어두면 된다.
- 이렇게 하면 해당 클래스의 인스턴스를 생성하는 시점에 원하는 타입을 전달하여
타입 매개변수 자리에 전달한 타입을 지정할 수 있다.
```java
public class GenericBox<T> {

    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}
```
- 제네릭 클래스 사용
```java
public static void main(String[] args) {
    GenericBox<Integer> integerBox = new GenericBox<Integer>(); //생성 시점에 T의 타입 결정
    integerBox.set(10);
    //integerBox.set("문자100"); // Integer 타입만 허용, 컴파일 오류
    Integer integer = integerBox.get(); // Integer 타입 반환 (캐스팅 X)
    System.out.println("integer = " + integer);

    GenericBox<String> stringBox = new GenericBox<String>();
    stringBox.set("hello"); // String 타입만 허용
    String str = stringBox.get(); // String 타입만 반환
    System.out.println("str = " + str);

    //원하는 모든 타입 사용 가능
    GenericBox<Double> doubleBox = new GenericBox<Double>();
    doubleBox.set(10.5);
    Double doubleValue = doubleBox.get();
    System.out.println("doubleValue = " + doubleValue);

    //타입 추론: 생성하는 제네릭 타입 생략 가능
    GenericBox<Integer> integerBox2 = new GenericBox<>(); // 타입 추론:     
}
```

### 타입 추론
- 이전 코드를 보면 변수를 선언할 때와 객체를 생성할 때 <Integer> 가 두번 나온다.
- 자바는 타입 추론 기능을 제공하기 때문에 변수를 선언할 때만 타입을 적어주면
알아서 타입을 추론하기 때문제 new 키워드 다음에는 타입을 지정하지 않아도 된다.
```java
GenericBox<Integer> integerBox = new GenericBox<Integer>() // 타입 직접 입력
GenericBox<Integer> integerBox2 = new GenericBox<>() // 타입 추론
```